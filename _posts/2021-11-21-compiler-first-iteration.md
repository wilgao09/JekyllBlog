---
layout: post
title:  "Compiler First Iteration: Barebones Flex and Bison in C"
date:   2021-11-21 15:15:12 -0500
categories: jekyll update
---
This blogpost will be the first in a series of blogposts about my time constructing a compiler. As of writing this, the specs for the final language have not been decided yet.

These posts should not be followed as a tutorial, as I, too, am discovering how designing works.

This post will be dedicated to introducing Flex, a tokenizer, and Bison, a CFG parser.

## What is Flex
Flex is a tokenizier, i.e. it takes an input string and breaks it into known tokens using some regex. For example, 

{% highlight c %}
[0-9]+       {yylval.num=atoi(yytext); return INTLIT;}

[a-z]+    {yylval.str = yytext;   return VIDEN;}

[ \t\r\n]
{% endhighlight %}

would specify that each sequence of one or more digits be turned into an <code> INTLIT </code> and each sequence of one or more alphabet characters be turned into a <code> VIDEN</code>. More on what or where <code> INTLIT </code> or <code> VIDEN </code> later.

Lexing is valuable because it converts a raw string into tokens: instead of manually matching, we can have Flex match for us. After matching, Flex will execute the code in the braces to the right of the regex. <code> yytext </code> is a pointer to the string containing the characters matched.


## What is Bison
Bison parses any CFG, i.e., it takes a sequence of inputs and verifies if the sequence is valid given the rules. For example, 

{% highlight c %}

file: statement file |;

statement: decl SCOLON| assn SCOLON| func SCOLON;

{% endhighlight %}

would specify two different rules: "a file is composed of a statement and a file or nothing" and "a statement is composed of a decl, an assn, or a func (all followed by SCOLON). "a file is composed of a statement and a file or nothing" can be recursively applied and reduced to "a file is composed of any number of statements". 

Like Flex, we can insert C code in braces that executes after a successful rule match. 

## Merging Flex and Bison.

Flex and Bison were designed to work with each other: tokens identified by a lexer written in Flex can be fed into a CFG parser written in Bison. 

We declare the list of tokens and rules (along with their types) in Bison: 
{% highlight c %}

%token  <num> INTLIT  
%token  <str> TYPEIDEN VIDEN 

%token  COLON   SCOLON  LPAREN  RPAREN  PRINTER EQSYM 

%type<str> var_iden
%type<num> int_lit

{% endhighlight %}

Several things to note: <code> \<num\> </code> and <code> \<str\> </code> are NOT builtins. These are names I defined, which will reappear later. What is important is that <code> \<num\> </code> and <code> \<str\> </code> refer to something of type <code> int </code> and something of type <code> char*</code>, respectively. Additionally, tokens with no type prefixed (<code> COLON SCOLON LPAREN RPAREN PRINTER EQSYM </code>) have no type: they carry no value other than existence. 

When using Flex with Bison, values extracted from Flex must be used again when applying rules in Bison. Extracted values are transferred in yyval (also defined in your Bison file). 

{% highlight c %}

%union {
    int num;
    char* str;
}


{% endhighlight %}

This is where code> \<num\> </code> and <code> \<str\> </code> come from: when we define the type of the token, we also specify where the token value comes from. 

The Bison file should also define <code> int main(int argc, char**argv) </code>, <code> void yyerror(char *s) </code>, and <code> int yywrap(void) </code>. Here is what I have: 

{% highlight c %}
int main(int argc, char **argv) {

  yyparse();
}

void yyerror(char *s)
{
  fprintf(stderr, "error: %s\n", s);
}

int yywrap(void) {
  return 1;
}
{% endhighlight %}

My final Bison file looks something like :
{% highlight c %}
%{
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
    yydebug = 1;



%}

%token  <num> INTLIT  
%token  <str> TYPEIDEN VIDEN 

%token  COLON   SCOLON  LPAREN  RPAREN  PRINTER EQSYM 

%type<str> var_iden
%type<num> int_lit

%union {
    int num;
    char* str;
}


%%
//RULES HERE
%%

int main(int argc, char **argv) {
  yyparse();
}


void yyerror(char *s)
{
  fprintf(stderr, "error: %s\n", s);
}

int yywrap(void) {
  return 1;
}
{% endhighlight %}

The Flex file looks like:

{% highlight c %}
%{
    #include "parse.tab.h"
%}

%%

[0-9]+       {yylval.num=atoi(yytext); return INTLIT;}
"print"     {return PRINTER;}
("int"|"char")  {yylval.str = yytext ;  return TYPEIDEN;}

":"         {return  COLON;}
";"         {return SCOLON;}
"("         {return LPAREN;}
")"         {return RPAREN;}    
"="         {return EQSYM;}
[a-z]+    {yylval.str = yytext;   return VIDEN;}

[ \t\r\n]
%%

{% endhighlight %}

Note that the flex file needs to include the header file generated by bison. In my case, it is called <code> parse.tab.h </code>.

## Testing Flex+Bison

Testing them together is relatively simple. Here is my Makefile:

{% highlight make %}
test_parse: lexer.l parse.y
	flex -d lexer.l 
	bison -d -t parse.y 
	gcc lex.yy.c parse.tab.c datas.c -o outt -lfl -g
{% endhighlight %}

When <code> ./outt </code> is run, it will expect input from stdin. 

## Next steps

With knowledge of how flex and bison could be used, we can define a syntax and start working towards a very very primitive compiler. The next step will include the data structures required to keep track of variables and references (likely a HashTable and a ParseTree).